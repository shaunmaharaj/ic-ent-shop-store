{"version":3,"sources":["webpack://UnataWidgets/./packages/enterprise-ui-address-autocomplete/AddressOption.tsx","webpack://UnataWidgets/./packages/enterprise-ui-address-autocomplete/AddressAutocomplete.tsx","webpack://UnataWidgets/./packages/enterprise-ui-address-autocomplete/AddressAutocompleteContainer.tsx"],"names":["useStyles","createStyles","tokens","container","display","alignItems","padding","utils","toPx","border","width","thick","icon","marginRight","size","spacing","xSmall","color","neutral","grey4","address","flexFlow","label","black","fontSize","font","body","detail","caption","AddressOption","selected","styles","style","role","aria-selected","data-test","defaultText","loadingMessage","noOptionsMessage","placeholder","loadingDots","margin","medium","error","marginTop","xxSmall","ui","AddressAutocompleteForm","selectId","ariaLabel","onAddressSelected","country","requireFullAddress","initialOption","valid","disabled","inputSize","fullWidth","selectAllOnFocus","props","useTokens","fieldContext","Boolean","required","getSelectTheme","selectThemeCreator","selectStyles","getSelectStyles","context","getBorderColor","state","isFocused","brand","primary","dark","success","regular","option","provided","valueContainer","paddingLeft","small","paddingRight","xxLarge","marginLeft","radius","control","borderColor","borderWidth","cursor","isDisabled","boxShadow","getSelectStyleOverrides","selectedOption","setSelectedOption","useState","query","setQuery","useEffect","data","isLoading","useAddressAutocomplete","undefined","id","aria-label","aria-describedby","aria-expanded","options","length","map","value","filter","location_type","createOptions","formatOptionLabel","components","IndicatorSeparator","DropdownIndicator","LoadingIndicator","openMenuOnClick","blurInputOnSelect","inputValue","onChange","action","onInputChange","onFocus","event","input","target","setTimeout","select","theme","aria-live","AddressAutocompleteContainer","config","suspense","AddressAutocomplete"],"mappings":"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","file":"93.js","sourcesContent":["import React from 'react'\nimport { createStyles, Icon, utils } from '@instacart/cocktail'\nimport { Address } from './AddressAutocomplete'\n\nexport interface AddressOptionProps {\n  /* Addresses from the autocomplete service */\n  address: Address\n  selected?: boolean\n}\n\nconst useStyles = createStyles(tokens => ({\n  container: {\n    display: 'flex',\n    alignItems: 'center',\n    padding: utils.toPx`${tokens.border.width.thick} 0`,\n  },\n  icon: {\n    marginRight: tokens.size.spacing.xSmall,\n    color: tokens.color.neutral.grey4,\n  },\n  address: {\n    display: 'flex',\n    flexFlow: 'column nowrap',\n  },\n  label: {\n    color: tokens.color.neutral.black,\n    fontSize: tokens.size.font.body,\n  },\n  detail: {\n    color: tokens.color.neutral.grey4,\n    fontSize: tokens.size.font.caption,\n  },\n}))\n\nconst AddressOption: React.FC<AddressOptionProps> = ({ address, selected }) => {\n  const styles = useStyles()\n\n  return (\n    <div style={styles.container} role=\"option\" aria-selected={!!selected}>\n      <Icon icon=\"icon-pin\" size={20} style={styles.icon} />\n      <div style={styles.address}>\n        <span style={styles.label} data-test=\"address-label\">\n          {address.label}\n        </span>\n        <span style={styles.detail} data-test=\"address-detail\">\n          {address.detail}\n        </span>\n      </div>\n    </div>\n  )\n}\n\nexport default AddressOption\n","import React, { CSSProperties, useState, useEffect } from 'react'\nimport ReactSelect, { ActionMeta, ValueType, InputActionMeta } from 'react-select'\nimport { useAddressAutocomplete } from '@instacart/enterprise-services-hooks'\nimport {\n  createStyles,\n  LoadingDots,\n  utils,\n  useTokens,\n  selectThemeCreator,\n  getSelectStyles,\n  FormHelpText,\n} from '@instacart/cocktail'\nimport { FormControlContextProps } from '@instacart/cocktail/FormControl/FormControlContext'\nimport { Tokens } from '@instacart/cocktail-design-tokens'\nimport AddressOption from './AddressOption'\n\nexport interface AddressAutocompleteProps {\n  /* ID of the container */\n  selectId: string\n  /* ARIA label of the container */\n  ariaLabel: string\n  /* Callback when the user selects an address */\n  onAddressSelected: (option: Address | null) => void\n  /* Country to use for the location API. Defaults to US */\n  country?: 'US' | 'CA'\n  /* Whether to require a complete address or just a postal code */\n  requireFullAddress?: boolean\n  /* Pre-poulate the field with selected option */\n  initialOption?: AddressSelectOption\n  /* Error message if the field is invalid */\n  error?: string\n  /* Whether the field is considered valid */\n  valid?: boolean\n  /* Whether the field is disabled */\n  disabled?: boolean\n  /* Height of the field */\n  inputSize?: 'small' | 'regular' | 'large'\n  /* Whether the container is block or inline-block */\n  fullWidth?: boolean\n  /* Message to display while loading */\n  loadingMessage?: string\n  /* Message to display if no address can be found */\n  noOptionsMessage?: string\n  /* Placeholder message */\n  placeholder?: string\n  /* Select all input text on focus */\n  selectAllOnFocus?: boolean\n}\n\nexport interface Address {\n  /* Used for the second line of the address display */\n  detail: string\n  /* Used for the first line of the address display */\n  label: string\n  /* Object containing all address details */\n  location: object\n  /* 'address' or 'postal_code' */\n  location_type: string\n}\n\nexport type AddressSelectOption = {\n  label: string\n  value: Address\n}\n\ninterface AutocompleteData {\n  options: Array<Address>\n}\n\nconst defaultText = {\n  loadingMessage: 'Loading...',\n  noOptionsMessage: 'No addresses found',\n  placeholder: 'Address or ZIP Code',\n}\n\nconst useStyles = createStyles(tokens => ({\n  loadingDots: {\n    margin: utils.toPx`0 ${tokens.size.spacing.medium}`,\n  },\n  error: {\n    marginTop: tokens.size.spacing.xxSmall,\n    color: tokens.color.ui.error,\n  },\n}))\n\nconst getSelectStyleOverrides = (tokens: Tokens, context: FormControlContextProps) => {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const getBorderColor = (state: any) =>\n    state.isFocused\n      ? tokens.color.brand.primary.dark\n      : context.error\n      ? tokens.color.ui.error\n      : context.valid\n      ? tokens.color.ui.success\n      : tokens.color.border.regular\n\n  return {\n    option: (provided: CSSProperties) => provided,\n    valueContainer: (provided: CSSProperties) => ({\n      ...provided,\n      paddingLeft: tokens.size.spacing.small,\n      paddingRight: tokens.size.spacing.xxLarge,\n      marginLeft: tokens.border.radius.small,\n    }),\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    control: (provided: CSSProperties, state: any) => ({\n      ...provided,\n      borderColor: getBorderColor(state),\n      borderWidth: tokens.border.width.regular,\n      cursor: state.isDisabled ? 'not-allowed' : 'text',\n      '&:hover': { borderColor: getBorderColor(state) },\n      '&:focus': { boxShadow: utils.toPx`0 0 0 1px ${tokens.color.brand.primary.dark}` },\n    }),\n  }\n}\n\nconst AddressAutocompleteForm: React.FC<AddressAutocompleteProps> = ({\n  selectId,\n  ariaLabel,\n  onAddressSelected,\n  country,\n  requireFullAddress = false,\n  initialOption = null,\n  error,\n  valid,\n  disabled = false,\n  inputSize = 'regular',\n  fullWidth = true,\n  loadingMessage = defaultText.loadingMessage,\n  noOptionsMessage = defaultText.noOptionsMessage,\n  placeholder = defaultText.placeholder,\n  selectAllOnFocus = false,\n  ...props\n}) => {\n  const styles = useStyles()\n  const tokens = useTokens()\n\n  const fieldContext = {\n    error: Boolean(error),\n    disabled,\n    fullWidth,\n    inputSize,\n    // Not used for anything\n    required: false,\n    valid,\n  }\n  const getSelectTheme = selectThemeCreator(tokens, fieldContext)\n  const selectStyles = {\n    ...getSelectStyles(tokens, fieldContext, 200),\n    ...getSelectStyleOverrides(tokens, fieldContext),\n  }\n\n  const [selectedOption, setSelectedOption] = useState<AddressSelectOption | null>(initialOption)\n  const [query, setQuery] = useState('')\n\n  // Ensure that selected option changes if initialOption is changed async\n  useEffect(() => {\n    if (initialOption) {\n      setSelectedOption(initialOption)\n    }\n  }, [initialOption])\n\n  const createOptions = (data: AutocompleteData): Array<AddressSelectOption> => {\n    const options = data?.options?.map((address: Address) => ({\n      label: `${address.label} ${address.detail}`,\n      value: address,\n    }))\n    return options && requireFullAddress\n      ? options.filter((option: AddressSelectOption) => option.value.location_type === 'address')\n      : options\n  }\n\n  const handleChange = (option: ValueType<AddressSelectOption>, { action }: ActionMeta) => {\n    // Action is 'set-value' only when setValue is used\n    if (action !== 'set-value') {\n      setSelectedOption(option as AddressSelectOption)\n      onAddressSelected((option as AddressSelectOption).value)\n    }\n  }\n\n  const handleInputChange = (value: string, { action }: InputActionMeta) => {\n    setQuery(value)\n    // If the input is cleared, clear the selected option\n    if (action === 'input-change' && value === '') {\n      setSelectedOption(null)\n      onAddressSelected(null)\n    }\n\n    return null\n  }\n\n  const handleFocus = (event: React.FocusEvent<HTMLElement>) => {\n    if (selectedOption && selectedOption.label) {\n      setQuery(selectedOption.label)\n    }\n    if (selectAllOnFocus) {\n      const input = event.target as HTMLInputElement\n      setTimeout(() => {\n        input.select()\n      }, 0)\n    }\n  }\n\n  // TODO: Error handling\n  const { data, isLoading } = useAddressAutocomplete(query ? { query, country } : undefined)\n\n  return (\n    <>\n      <ReactSelect\n        id={selectId}\n        aria-label={ariaLabel}\n        aria-describedby={`${selectId}-error`}\n        aria-expanded={data?.options?.length > 0 ? 'true' : 'false'}\n        isDisabled={disabled}\n        isLoading={isLoading}\n        options={createOptions(data)}\n        formatOptionLabel={option => (\n          <AddressOption address={option.value} selected={selectedOption?.label === option.label} />\n        )}\n        components={{\n          // Remove the seprator line\n          IndicatorSeparator: () => null,\n          // Remove the dropdown chevron\n          DropdownIndicator: () => null,\n          // Use our own loading dots\n          // eslint-disable-next-line react/no-multi-comp\n          LoadingIndicator: () => (\n            <span style={styles.loadingDots}>\n              <LoadingDots />\n            </span>\n          ),\n        }}\n        loadingMessage={() => loadingMessage}\n        noOptionsMessage={() => noOptionsMessage}\n        placeholder={placeholder}\n        // Only open when the user types\n        openMenuOnClick={false}\n        blurInputOnSelect\n        value={selectedOption}\n        inputValue={query}\n        onChange={handleChange}\n        onInputChange={handleInputChange}\n        onFocus={handleFocus}\n        theme={getSelectTheme}\n        styles={selectStyles}\n        data-test=\"address-select\"\n        {...props}\n      />\n      {error && (\n        <FormHelpText\n          id={`${selectId}-error`}\n          aria-live=\"assertive\"\n          style={styles.error}\n          data-test=\"error-text\"\n        >\n          {error}\n        </FormHelpText>\n      )}\n    </>\n  )\n}\n\nexport default AddressAutocompleteForm\n","import React from 'react'\nimport { QueryConfigProvider } from '@instacart/enterprise-services-hooks'\nimport AddressAutocomplete, { AddressAutocompleteProps } from './AddressAutocomplete'\n\nconst AddressAutocompleteContainer: React.FC<AddressAutocompleteProps> = props => {\n  // Disable suspense for manual loading control\n  const queryConfig = { suspense: false }\n  return (\n    <QueryConfigProvider config={queryConfig}>\n      <AddressAutocomplete {...props} />\n    </QueryConfigProvider>\n  )\n}\n\nexport default AddressAutocompleteContainer\n"],"sourceRoot":""}